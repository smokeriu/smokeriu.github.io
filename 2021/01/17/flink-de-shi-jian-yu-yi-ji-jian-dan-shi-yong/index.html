<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-material.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.ibuer.fun","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文Flink API版本：java-1.12   注1 ： Flink在1.11后，通过WatermarkStrategy来指定水位线及事件时间。将AssignerWithPeriodicWatermarks和AssignerWithPunctuatedWatermarks标记为过时。本文也主要是记录新接口的使用方法。 注2 ： Flink在1.12（大概）后，默认的时间策略为事件时间。 注3">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink的时间语义及简单使用">
<meta property="og:url" content="http://blog.ibuer.fun/2021/01/17/flink-de-shi-jian-yu-yi-ji-jian-dan-shi-yong/index.html">
<meta property="og:site_name" content="Ssiu Blog">
<meta property="og:description" content="本文Flink API版本：java-1.12   注1 ： Flink在1.11后，通过WatermarkStrategy来指定水位线及事件时间。将AssignerWithPeriodicWatermarks和AssignerWithPunctuatedWatermarks标记为过时。本文也主要是记录新接口的使用方法。 注2 ： Flink在1.12（大概）后，默认的时间策略为事件时间。 注3">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-17T04:54:01.000Z">
<meta property="article:modified_time" content="2021-07-25T03:53:07.051Z">
<meta property="article:author" content="Ssiu">
<meta property="article:tag" content="Flink">
<meta property="article:tag" content="Time">
<meta property="article:tag" content="Window">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.ibuer.fun/2021/01/17/flink-de-shi-jian-yu-yi-ji-jian-dan-shi-yong/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Flink的时间语义及简单使用 | Ssiu Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ssiu Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.ibuer.fun/2021/01/17/flink-de-shi-jian-yu-yi-ji-jian-dan-shi-yong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ssiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ssiu Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flink的时间语义及简单使用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-17 12:54:01" itemprop="dateCreated datePublished" datetime="2021-01-17T12:54:01+08:00">2021-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-25 11:53:07" itemprop="dateModified" datetime="2021-07-25T11:53:07+08:00">2021-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flink/" itemprop="url" rel="index"><span itemprop="name">Flink</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>本文Flink API版本：java-1.12</p>
</blockquote>
<blockquote>
<p>注1 ： Flink在1.11后，通过WatermarkStrategy来指定水位线及事件时间。将AssignerWithPeriodicWatermarks<code>和</code>AssignerWithPunctuatedWatermarks标记为过时。本文也主要是记录新接口的使用方法。</p>
<p>注2 ： Flink在1.12（大概）后，默认的时间策略为事件时间。</p>
<p>注3 ： 本文主要以Kafka作为输入元为例。仅简单介绍用法，共后续使用时的资料翻阅。</p>
<p>注4 ： 为了前后的连贯性，本文将不讨论在1.12中已被标记为过时的方法。若需使用早先的API，可翻阅其他资料。</p>
</blockquote>
<h2 id="分配时间戳和生成水位线"><a href="#分配时间戳和生成水位线" class="headerlink" title="分配时间戳和生成水位线"></a>分配时间戳和生成水位线</h2><p>使用事件时间，需要提供数据中<strong>代表时间的字段</strong>，并指定水位线。在新的FlinkAPI中，提供了常见的默认实现，来将时间戳的分配简单化：</p>
<h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><p>简单使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WatermarkStrategy&lt;ObjectNode&gt; watermarkStrategy = WatermarkStrategy.</span><br><span class="line">				&lt;ObjectNode&gt;forBoundedOutOfOrderness(Duration.ofMillis(<span class="number">10</span>*<span class="number">1000</span>))</span><br><span class="line">				.withTimestampAssigner((SerializableTimestampAssigner&lt;ObjectNode&gt;) (element, recordTimestamp) -&gt; element.get(<span class="string">&quot;value&quot;</span>).get(<span class="string">&quot;log_time&quot;</span>).longValue());</span><br></pre></td></tr></table></figure>

<h4 id="水位线分配"><a href="#水位线分配" class="headerlink" title="水位线分配"></a>水位线分配</h4><p>通过调用WatermarkStrategy接口的默认方法，可以直接使用内置的通用策略。分别是</p>
<ul>
<li><p><code>forMonotonousTimestamps()</code>：单调递增的水位线分配器。</p>
<ul>
<li><p>当前时间的时间戳就充当watermark，如果后续数据时间戳更小，则认为是过期数据。</p>
</li>
<li><p>对于并行数据源。则是每个分区独立计算。</p>
<ul>
<li><blockquote>
<p>注释原文：</p>
<p>Creates a watermark strategy for situations with monotonously ascending timestamps.<br>The watermarks are generated periodically and tightly follow the latest timestamp in the data. The delay introduced by this strategy is mainly the periodic interval in which the watermarks are generated.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>forBoundedOutOfOrderness(Duration.ofSeconds(10))</code></p>
<ul>
<li><p>参数表示数据之间允许的最大延迟。</p>
</li>
<li><p>如果新数据的时间戳 比 <strong>水位线-最大延迟 还要小</strong>。则认为是过期数据</p>
<ul>
<li><blockquote>
<p>注释原文：</p>
<p>Creates a watermark strategy for situations where records are out of order, but you can place an upper bound on how far the events are out of order. An out-of-order bound B means that once the an event with timestamp T was encountered, no events older than T - B will follow any more.<br>The watermarks are generated periodically. The delay introduced by this watermark strategy is the periodic interval length, plus the out of orderness bound.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>默认实现的水位线是周期性分配的。</p>
<ul>
<li>分配的周期取决于取决于<code>ExecutionConfig.getAutoWatermarkInterval()</code>。</li>
<li>该间隔可通过<code>env.getConfig().setAutoWatermarkInterval(long interval_ms)</code>设置。</li>
</ul>
</li>
</ul>
<h4 id="分配事件时间戳"><a href="#分配事件时间戳" class="headerlink" title="分配事件时间戳"></a>分配事件时间戳</h4><p>通过*.withTimestampAssigner*,可指定如何将数据的某个字段分配为时间戳，对于Kafka来说，若不指定则是将Kafka的record-time作为事件时间。</p>
<p>Flink提供两种方式来指定：</p>
<ul>
<li><p>TimestampAssignerSupplier<T>：为时间分配器提供更多上下文。</p>
<ul>
<li><p>实现方法需要返回一个TimestampAssigner。</p>
<ul>
<li><blockquote>
<p>注释原文：</p>
<p>You can use this when a TimestampAssigner needs additional context, for example access to the metrics system.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SerializableTimestampAssigner<T> ：指定如何将数据的某个字段分配为时间戳</p>
<ul>
<li><p>实现extractTimestamp方法，用来指定时间戳</p>
</li>
<li><p>SerializableTimestampAssigner实现的就是TimestampAssigner，并增加了序列化。</p>
<ul>
<li><blockquote>
<p>注释原文：</p>
<p>You can use this in case you want to specify a TimestampAssigner via a lambda function.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="空闲数据"><a href="#空闲数据" class="headerlink" title="空闲数据"></a>空闲数据</h4><blockquote>
<p>摘自官网：</p>
<p>如果数据源中的某一个分区/分片在一段时间内未发送事件数据，则意味着 <code>WatermarkGenerator</code> 也不会获得任何新数据去生成 watermark。在这种情况下，当某些其他分区仍然发送事件数据的时候就会出现问题。由于下游算子 watermark 的计算方式是取所有不同的上游并行数据源 watermark 的最小值，则其 watermark 将不会发生变化。</p>
<p>故可以使用 <code>WatermarkStrategy</code> 来检测空闲输入并将其标记为空闲状态。</p>
</blockquote>
<p>WatermarkStrategy接口提供了<code>withIdleness(Duration idleTimeout)</code>默认方法。</p>
<p>即当某一个分区超过<em>多长时间</em>没有数据时，则标记为空闲。就算该分区的水位线没有变化，也不会影响整体水位线的变化。</p>
<ul>
<li><blockquote>
<p>注释原文：</p>
<p>Creates a new enriched WatermarkStrategy that also does idleness detection in the created WatermarkGenerator.<br>Add an idle timeout to the watermark strategy. If no records flow in a partition of a stream for that amount of time, then that partition is considered “idle” and will not hold back the progress of watermarks in downstream operators.<br>Idleness can be important if some partitions have little data and might not have events during some periods. Without idleness, these streams can stall the overall event time progress of the application</p>
</blockquote>
</li>
</ul>
<h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ul>
<li>需<code>&lt;ObjectNode&gt;forBoundedOutOfOrderness</code>这般显示指定数据类型。</li>
</ul>
<h3 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h3><p>可以实现WatermarkStrategy接口，来自定义水位线策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> WatermarkStrategy&lt;ObjectNode&gt;() &#123;</span><br><span class="line">	<span class="comment">// 必须实现</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WatermarkGenerator&lt;ObjectNode&gt; <span class="title">createWatermarkGenerator</span><span class="params">(WatermarkGeneratorSupplier.Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> WatermarkGenerator&lt;ObjectNode&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(ObjectNode event, <span class="keyword">long</span> eventTimestamp, WatermarkOutput output)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择实现</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TimestampAssigner&lt;ObjectNode&gt; <span class="title">createTimestampAssigner</span><span class="params">(TimestampAssignerSupplier.Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><ul>
<li><p><code>createWatermarkGenerator</code>：必须实现</p>
<ul>
<li><p>方法需要返回一个<code>WatermarkGenerator</code>。可以通过实现对应接口自定义。</p>
<ul>
<li><code>onEvent(T event, long eventTimestamp, WatermarkOutput output)</code><ul>
<li>每条记录都会调用。根据记录记住事件时间戳，或更新水位线。</li>
</ul>
</li>
<li><code>onPeriodicEmit(WatermarkOutput output)</code><ul>
<li>定期调用。可能生成新的时间戳（也可能不会）生成间隔取决于ExecutionConfig.getAutoWatermarkInterval()</li>
</ul>
</li>
</ul>
</li>
<li><p>watermark 的生成方式本质上是有两种：<em>周期性生成</em> 和 <em>标记生成</em>。</p>
</li>
<li><p><strong>周期性</strong>生成器通常的实现逻辑：</p>
<ul>
<li><p>通过 <code>onEvent()</code>更新事件时间戳。</p>
</li>
<li><p>通过<code>onPeriodicEmit()</code>发出水位线。注意：<em>onPeriodicEmit方法的调用是定时调用的</em></p>
</li>
<li><blockquote>
<p> 官网示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedOutOfOrdernessGenerator</span> <span class="keyword">implements</span> <span class="title">WatermarkGenerator</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxOutOfOrderness = <span class="number">3500</span>; <span class="comment">// 3.5 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> currentMaxTimestamp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MyEvent event, <span class="keyword">long</span> eventTimestamp, WatermarkOutput output)</span> </span>&#123;</span><br><span class="line">        currentMaxTimestamp = Math.max(currentMaxTimestamp, eventTimestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发出的 watermark = 当前最大时间戳 - 最大乱序时间</span></span><br><span class="line">        output.emitWatermark(<span class="keyword">new</span> Watermark(currentMaxTimestamp - maxOutOfOrderness - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ul>
</li>
<li><p><strong>标记</strong>生成器通常的实现逻辑：</p>
<ul>
<li><p>通过 <code>onEvent()</code>判断是否需要更新（如数据中明确的字段值），如果需要则直接更新。</p>
</li>
<li><blockquote>
<p>官网示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class PunctuatedAssigner implements WatermarkGenerator&lt;MyEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onEvent(MyEvent event, long eventTimestamp, WatermarkOutput output) &#123;</span><br><span class="line">     if (event.hasWatermarkMarker()) &#123;</span><br><span class="line">         output.emitWatermark(new Watermark(event.getWatermarkTimestamp()));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onPeriodicEmit(WatermarkOutput output) &#123;</span><br><span class="line">     // onEvent 中已经实现</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>createTimestampAssigner</code>：选择实现</p>
<ul>
<li>参考：[分配事件时间戳](# 分配事件时间戳)</li>
</ul>
</li>
</ul>
<h3 id="为数据源指定事件时间"><a href="#为数据源指定事件时间" class="headerlink" title="为数据源指定事件时间"></a>为数据源指定事件时间</h3><p>通过上述过程，我们很容易得到一个<strong>WatermarkStrategy</strong>，通过这个，我们就能够用来指定数据中的事件时间戳和水位线了。</p>
<p>以Kafka为例，如果要修改默认的水位线策略，只需通过<code>.assignTimestampsAndWatermarks()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myConsumer.assignTimestampsAndWatermarks(watermarkStrategy);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>.assignTimestampsAndWatermarks</code>方法同样是DataStream中提供的方法。</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="使用事件时间及水位线"><a href="#使用事件时间及水位线" class="headerlink" title="使用事件时间及水位线"></a>使用事件时间及水位线</h2><p>todo 概述</p>
<h3 id="处理函数"><a href="#处理函数" class="headerlink" title="处理函数"></a>处理函数</h3><p>上述内容中得到的时间戳和水位线存放于程序的上下文<code>(Context ctx)</code>中，一般而言可以通过Process及相关的函数进行访问。</p>
<blockquote>
<p>处理函数都实现了RichFunction接口</p>
</blockquote>
<p>对于ProcessFunction，一般提供下述两个方法：</p>
<ul>
<li><code>processElement(I value, Context ctx, Collector&lt;O&gt; out)</code>：必须实现<ul>
<li>每条记录调用一次。</li>
<li>通过<code> Context ctx</code>访问<strong>时间戳</strong>。（也可以访问一些其他的上下文信息，如TimerService，将结果发往副结果）</li>
</ul>
</li>
<li><code>onTimer(long timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</code>：选择实现<ul>
<li>会在计时器触发时调用。<strong>故一般计时器会在<code>processElement</code>中设置</strong></li>
<li><code>timestamp</code>参数指的是触发计时器的时间戳。</li>
<li>用在<code>KeyedProcessFunction</code>中，用来在某些键值不再使用后，清除分区状态/或实现一些基于时间的自定义窗口逻辑。</li>
</ul>
</li>
<li>计时器：通过ctx的<code>timerService</code>使用<ul>
<li><strong>只能在键值流中使用计时器</strong>（*Setting timers is only supported on a keyed streams.*）</li>
<li>每个时间戳可以拥有一个计时器。一个key可以有多个计时器（key不同时，计时器的时间戳允许重复）</li>
<li><strong>不应该注册过多的计时器。建议在每个processFunction通过维护状态来管理计时器（注册+删除）。</strong></li>
<li>计时器触发后，就自动删除了？（todo）</li>
<li><code>timerService</code>：<ul>
<li><code>registerEventTimeTimer(long time)</code>：注册一个事件时间计时器。<ul>
<li>参数就相当于计时器id及出发条件。</li>
<li>当水位线时间戳 大于或等于计时器时间戳，则触发。</li>
</ul>
</li>
<li><code>deleteEventTimeTimer(long time)</code>：删除一个事件时间计时器</li>
<li><code>currentProcessingTime()</code>返回当前的处理时间</li>
<li><code>currentWatermark()</code>返回当前水位线</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="窗口算子"><a href="#窗口算子" class="headerlink" title="窗口算子"></a>窗口算子</h3><blockquote>
<p>1、本文只考虑基于时间的窗口。</p>
<p>2、窗口可用于键值与非键值数据流。本文主要以键值数据流为例进行说明。</p>
<p>3、对于键值数据流，窗口算子为并行计算。对于非键值，考虑到需要处理整个窗口的所有元素，需要单线程处理。</p>
</blockquote>
<p>实际使用窗口算子时，必需要指定两个窗口组件：</p>
<ul>
<li>窗口分配器<code>WindowAssigner</code>，得到<code>WindowedStream</code>：决定了元素如何划分到不同的窗口中。</li>
<li>作用于<code>WindowedStream</code>上的处理函数：如何处理单个窗口中的数据。</li>
</ul>
<p>如果需要自定义某些实现逻辑，还可以指定其他窗口组件：</p>
<ul>
<li>触发器<code>trigger</code>：定义了窗口何时准备好执行计算、何时需要清除自身内容。</li>
<li>移除器<code>evictor</code>：用来从窗口中删除已收集元素。可以在ProcessWindowFunc前/后使用。</li>
</ul>
<p>简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">baseInput.keyBy(((KeySelector&lt;Tuple4&lt;Integer, Long, Long, String&gt;, Integer&gt;) value -&gt; value.f0))</span><br><span class="line">				.window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">1</span>)))</span><br><span class="line">				.process(<span class="keyword">new</span> ProcessWindowFunction&lt;Tuple4&lt;Integer, Long, Long, String&gt;, String, Integer, TimeWindow&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Integer integer, Context context, Iterable&lt;Tuple4&lt;Integer, Long, Long, String&gt;&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">						buffer.append(integer).append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">						elements.forEach(ele -&gt; buffer.append(ele.f3).append(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">						out.collect(buffer.toString());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="窗口分配器"><a href="#窗口分配器" class="headerlink" title="窗口分配器"></a>窗口分配器</h4><h5 id="内置窗口分配器"><a href="#内置窗口分配器" class="headerlink" title="内置窗口分配器"></a>内置窗口分配器</h5><ul>
<li><p>TumblingWindow（滚动窗口）：下一个窗口的开始为：这个窗口的结束时间。</p>
<ul>
<li><p>提供两个内置实现（事件时间和处理时间各一个）：</p>
<ul>
<li><p><code>TumblingEventTimeWindows</code>：基于事件时间的滚动窗口。</p>
</li>
<li><p><code>of</code>方法接收参数：</p>
<ul>
<li><p>size : 窗口大小</p>
</li>
<li><p>offset : 偏移量。相比于UTC±00:00。否则第一个滚动窗口开始时间一定是0点。</p>
</li>
<li><p>windowStagger：交错策略。实际源码中表现为会影响offset的效果。</p>
<ul>
<li><blockquote>
<p>The utility that produces staggering offset in runtime. </p>
<p>有三类：</p>
<p>​    ALIGNED：默认。不产生任何影响。所有分区的窗口开始时间都是一样的</p>
<p>​    RANDOM：加入一个随机值作为交错参数。即每个分区的第一个窗口的开始时间会随机开始。</p>
<p>​    NATURAL：根据每个线程得到的第一个元素，来作为该分区的第一个窗口的开始时间。</p>
<p>（待验证）</p>
<p>Flink会在WindowOperator中的processElement方法中，对每个接收到的流元素进行窗口画风。而这个参数会影响到最后生成的elementWindows，windowStagger主要就是通过影响offset，来影响elementWindows的生成。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>窗口大小决定了多久会生成一个新的窗口。</p>
</li>
</ul>
</li>
<li><p>SlidingTimeWindow（滑动窗口）：下一个窗口开始时间为：这个窗口开始时间+滑动距离。</p>
<ul>
<li>提供两个内置实现（事件时间和处理时间各一个）：<ul>
<li><code>SlidingEventTimeWindows</code>：基于事件时间的滑动窗口。</li>
<li><code>of</code>方法接收参数：<ul>
<li>size : 窗口大小。</li>
<li>slide：滑动距离。</li>
<li>offset : 偏移量。相比于UTC±00:00。否则第一个滚动窗口开始时间一定是0点。</li>
</ul>
</li>
</ul>
</li>
<li>滑动距离决定了多久会生成一个新的窗口。</li>
</ul>
</li>
<li><p>sessionWindow（会话窗口）：下一个窗口开始时间为：新元素到达 且距离上一个元素到达时间超过阈值。</p>
<ul>
<li><p>提供两类(动态和固定)，供四个（事件时间和处理时间各两个）内置实现：</p>
<ul>
<li><p><code>EventTimeSessionWindows</code>：基于事件时间的会话窗口。</p>
<ul>
<li>方法：<ul>
<li><code>withGap(Time size)</code>：间隔阈值。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>DynamicEventTimeSessionWindows</code>：基于事件时间的动态会话窗口。</p>
<ul>
<li><p>方法：</p>
<ul>
<li><p><code>withDynamicGap(SessionWindowTimeGapExtractor&lt;T&gt; sessionWindowTimeGapExtractor)</code>：</p>
<ul>
<li><blockquote>
<p>SessionWindowTimeGapExtractor能够从数据中提取超时间隔。</p>
<p>即数据中可以有一个字段，来作为这条数据距离上一条数据多久。<code>SessionWindowTimeGapExtractor</code>接口需要手动实现。且只有一个方法，从数据中拿到这他的间隔<code>long extract(T element);</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>两者的主要区别：</p>
<ul>
<li>非动态：超时间隔是固定的。</li>
<li>动态：有数据自己决定是否划分新窗口。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>globalWindow（全局窗口）: 只会产生一个窗口</p>
<ul>
<li>不会自动触发，必须手动指定<em>触发器</em>。</li>
<li>必须指定<em>移除器</em>来移除窗口中的元素</li>
</ul>
</li>
</ul>
<h5 id="自定义窗口分配器"><a href="#自定义窗口分配器" class="headerlink" title="自定义窗口分配器"></a>自定义窗口分配器</h5><p><code>WindowAssigner</code>接口提供了四个方法需要实现：</p>
<ul>
<li><code>assignWindows(T element, long timestamp, WindowAssignerContext context)</code>：返回元素归属的窗口集合（这条记录归属哪些窗口）<ul>
<li>由于一般都是针对时间设计，所以一般都是返回TimeWindow。基于数量的窗口可以使用<code>countWindow</code></li>
</ul>
</li>
<li><code>getDefaultTrigger(StreamExecutionEnvironment env)</code>：返回该分配器的默认触发器。<ul>
<li>请参考自定义触发器，或者Trigger子类的内部实现。</li>
</ul>
</li>
<li><code>getWindowSerializer(ExecutionConfig executionConfig)</code>：返回窗口的TypeSerializer<ul>
<li>对于TimeWindow而言，则返回<code>new TimeWindow.Serializer()</code>即可。</li>
</ul>
</li>
<li><code>isEventTime()</code>：是否是事件时间窗口</li>
</ul>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>触发器决定何时对窗口进行计算并发出结果。每次调用触发器都会生成一个<code>TriggerResult</code>，用于决定窗口接下来的行为：</p>
<ul>
<li>CONTINUE：什么都不做。</li>
<li>FIRE：调用<code>ProcessFunction</code>（如果有使用），并发出结果。如果包含增量聚合函数，则直接发出结果。</li>
<li>PURGE：清空窗口内容，并删除窗口、及窗口元数据。并调用<code>ProcessWindowFunction.clear()</code>方法。</li>
<li>FIRE_AND_PURGE：先FIRE，再PURGE。</li>
</ul>
<h5 id="内置触发器"><a href="#内置触发器" class="headerlink" title="内置触发器"></a>内置触发器</h5><p>Flink提供一些内置的触发器，包括（只说明事件时间的，处理时间一样的）：</p>
<ul>
<li><p><code>EventTimeTrigger</code>：水位线大于窗口结束时间，则触发。</p>
</li>
<li><p><code>CountTrigger</code>：当窗口内元素数量大于阈值时则触发。</p>
</li>
<li><p><code>DeltaTrigger</code>：初始化是需要给定一个<code>DeltaFunction</code>，根据接入数据计算出来的Delta指标是否超过指定的Threshold去判断是否触发窗口计算。</p>
<ul>
<li>计算当前元素与上一个触发计算元素的Delta值来与阈值进行比较。</li>
</ul>
</li>
<li><p><code>ContinuousEventTimeTrigger</code>:</p>
<ul>
<li><p>水位线大于窗口结束时间，则触发。</p>
</li>
<li><p>定期设置处理时间计时器。（计时器触发时会调用触发器的<code>onEventTime</code>方法。详见自定义）</p>
<ul>
<li><blockquote>
<p>1、当第一个元素达到时，会根据时间间隔注册一个计时器。触发时间约为开始时间+时间间隔（<code>start = timestamp - (timestamp % interval)+interval</code>）</p>
<p>2、当计时器触发时（），进行判断。</p>
<p>​    2.1、如果触发事件 等于 窗口结束时间，则触发触发器。</p>
<p>​    2.2、其他情况，则判断计时器是否有效，若有效则触发触发器，并根据设定的间隔注册下一个计时器。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>PurgingTrigger</code>：是一个trigger的包装类。具体作用为：如果被包装的trigger触发返回FIRE，则PurgingTrigger将返回修改为FIRE_AND_PURGE，其他的返回值不做处理。</p>
<ul>
<li>通过<code>of(Trigger&lt;T, W&gt; nestedTrigger)</code>来包装其他<code>Trigger</code></li>
</ul>
</li>
<li><p><code>ProcessingTimeoutTrigger</code>是一个trigger的包装类，作用于处理时间。具体作用为：为元素配置处理时间超时。当到达超时时间时，清除触发器状态</p>
</li>
</ul>
<h5 id="自定义触发器"><a href="#自定义触发器" class="headerlink" title="自定义触发器"></a>自定义触发器</h5><p>自定义触发器需要实现触发器API的下述方法：</p>
<ul>
<li><code>onElement(T element, long timestamp, W window, TriggerContext ctx)</code>：每有元素添加到窗口时就调用。<ul>
<li>入参<code>long timestamp</code>为事件的时间属性。</li>
<li>入参<code>W window</code>为时间所属的窗口对象。（对于一个元素所属多个窗口时，会对应有多个触发器，每个触发器只负责一个窗口）</li>
</ul>
</li>
<li><code>onProcessingTime(long time, W window, TriggerContext ctx)</code>：处理时间计时器触发时调用。计时器通过ctx注册/清除。</li>
<li><code>onEventTime(long time, W window, TriggerContext ctx)</code>事件时间计时器触发时调用。计时器通过ctx注册/清除。<ul>
<li>入参<code>long time</code>为触发计时器的时间。等于计时器注册时间。</li>
</ul>
</li>
<li><code>canMerge()</code>：该触发器是否支持合并。</li>
<li><code>onMerge(W window, OnMergeContext ctx)</code>：合并逻辑（将多个窗口合并为一个窗口），需要合并时则调用该方法。<ul>
<li>在触发器与<code>MergingWindowAssigner</code>一起使用时，需要实现该方法。</li>
<li>触发器的自定义状态同样需要合并。</li>
<li>入参<code>W window</code>为合并后的窗口。</li>
</ul>
</li>
<li><code>clear(W window, TriggerContext ctx)</code>：在触发器中清除那些为给定窗口保存的状态。</li>
</ul>
<h4 id="移除器"><a href="#移除器" class="headerlink" title="移除器"></a>移除器</h4><p>用于在窗口执行计算前或计算后删除窗口中的元素。是一个可选组件。</p>
<h5 id="内置移除器"><a href="#内置移除器" class="headerlink" title="内置移除器"></a>内置移除器</h5><p>Flink提供了三类内置的<code>Evictor</code>：</p>
<ul>
<li><code>TimeEvictor</code>：以时间为判断标准，决定元素是否会被移除。<ul>
<li>该移除器初始化时需要赋予一个时间size大小。移除比 最大时间-size 还小的数据。</li>
</ul>
</li>
<li><code>CountEvictor</code>：以元素计数为标准，决定元素是否会被移除。<ul>
<li>该移除器初始化时需要赋予一个数量size大小。移除多余的元素。从前向后移除。</li>
</ul>
</li>
<li><code>DeltaEvictor</code>：DeltaEvictor通过计算DeltaFunction的值（依次传入每个元素和最后一个元素），并将其与threshold进行对比，如果函数计算结果大于等于threshold，则该元素会被移除。</li>
</ul>
<h5 id="自定义移除器"><a href="#自定义移除器" class="headerlink" title="自定义移除器"></a>自定义移除器</h5><p>自定义移除器需要实现移除器API的下述方法：</p>
<ul>
<li><code>evictBefore(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, int size, W window, EvictorContext ctx)</code>：窗口函数作用于窗口内容前调用。</li>
<li><code>evictAfter(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, int size, W window, EvictorContext ctx)</code>：窗口函数作用于窗口内容后调用。<ul>
<li>入参<code>(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements</code>：窗口中的元素集合。移除操作主要对这个集合处理。满足条件时<code>iterator.remove();</code></li>
<li>入参<code>int size</code>：当前的元素个数。</li>
<li>入参<code>W window</code>：本次处理的窗口。</li>
</ul>
</li>
</ul>
<h2 id="处理迟到数据"><a href="#处理迟到数据" class="headerlink" title="处理迟到数据"></a>处理迟到数据</h2><p>即便设置了水位线，也不可避免的会产生迟到数据。</p>
<blockquote>
<p>迟到数据一般是针对window而言，因为window需要聚合一段时间内的数据触发计算。</p>
<p>不需要window的情况下，在处理过程中其实对迟到数据不需要特殊处理。</p>
</blockquote>
<p>Flink提供了三种处理方案：</p>
<ul>
<li>直接丢弃。默认方案</li>
<li>基于迟到事件更新结果。</li>
<li>旁路输出。</li>
</ul>
<h3 id="基于迟到事件更新结果"><a href="#基于迟到事件更新结果" class="headerlink" title="基于迟到事件更新结果"></a>基于迟到事件更新结果</h3><p>Flink的<code>WindowedStream</code>提供了<code>allowedLateness(Time lateness)</code>方法。入参为允许延迟的时间（默认为0）。这个方法的作用和实现方式：</p>
<ul>
<li>当设置lateness不为0时，窗口被删除的时间会在原本的基础上推迟lateness。</li>
<li>当水位线触发计算后，每当有满足要求的迟到数据达到时，都会再次触发计算。</li>
</ul>
<h3 id="旁路输出"><a href="#旁路输出" class="headerlink" title="旁路输出"></a>旁路输出</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Flink/" rel="tag"># Flink</a>
              <a href="/tags/Time/" rel="tag"># Time</a>
              <a href="/tags/Window/" rel="tag"># Window</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/24/spark-3-datasourcev2-01/" rel="prev" title="spark-3 DataSourceV2-01">
      <i class="fa fa-chevron-left"></i> spark-3 DataSourceV2-01
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/30/flink-de-liu-shi-join/" rel="next" title="Flink的流式Join">
      Flink的流式Join <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%97%B6%E9%97%B4%E6%88%B3%E5%92%8C%E7%94%9F%E6%88%90%E6%B0%B4%E4%BD%8D%E7%BA%BF"><span class="nav-number">1.</span> <span class="nav-text">分配时间戳和生成水位线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.</span> <span class="nav-text">默认实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B4%E4%BD%8D%E7%BA%BF%E5%88%86%E9%85%8D"><span class="nav-number">1.1.1.</span> <span class="nav-text">水位线分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%E6%88%B3"><span class="nav-number">1.1.2.</span> <span class="nav-text">分配事件时间戳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.3.</span> <span class="nav-text">空闲数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="nav-number">1.1.4.</span> <span class="nav-text">注意点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.</span> <span class="nav-text">自定义实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">实现方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E6%8C%87%E5%AE%9A%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4"><span class="nav-number">1.3.</span> <span class="nav-text">为数据源指定事件时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.4.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%E5%8F%8A%E6%B0%B4%E4%BD%8D%E7%BA%BF"><span class="nav-number">2.</span> <span class="nav-text">使用事件时间及水位线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%AE%97%E5%AD%90"><span class="nav-number">2.2.</span> <span class="nav-text">窗口算子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">窗口分配器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%AA%97%E5%8F%A3%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">内置窗口分配器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E5%8F%A3%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">自定义窗口分配器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">2.2.2.</span> <span class="nav-text">触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">内置触发器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">自定义触发器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E5%99%A8"><span class="nav-number">2.2.3.</span> <span class="nav-text">移除器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%A7%BB%E9%99%A4%E5%99%A8"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">内置移除器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A7%BB%E9%99%A4%E5%99%A8"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">自定义移除器</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E8%BF%9F%E5%88%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">3.</span> <span class="nav-text">处理迟到数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%BF%9F%E5%88%B0%E4%BA%8B%E4%BB%B6%E6%9B%B4%E6%96%B0%E7%BB%93%E6%9E%9C"><span class="nav-number">3.1.</span> <span class="nav-text">基于迟到事件更新结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%81%E8%B7%AF%E8%BE%93%E5%87%BA"><span class="nav-number">3.2.</span> <span class="nav-text">旁路输出</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ssiu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ssiu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false}});</script></body>
</html>
